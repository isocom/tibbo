'*************************************************************************************************************************
'           Aggregate Agent Library
'	Agent Libarary is the interface for TIDE project to work with Tibbo AggreGate Server,
'	for more details on Agent and AggreGate please visit the website
'	http://aggregate.tibbo.com/docs/
'*************************************************************************************************************************


include "global.tbh"


type agg_context
	key_name as string(RECORD_NAME_LEN)
	context_name as string(CONTEXT_NAME_LEN)
	romaddr_def as word
end type

type agg_event
	event_name as string(RECORD_NAME_LEN)
	context_name as string(CONTEXT_NAME_LEN)
	event_level as string(1)
	event_fields(EVENT_FIELD_NUM) as string(EVENT_FIELD_SZ)
	disk_event as boolean
end type

type agg_table
	table_name as string(RECORD_NAME_LEN)
	context_name as string(CONTEXT_NAME_LEN)
	table_fields(TABLE_FIELD_NUM) as string(TABLE_FIELD_SZ)
end type

type agg_variable
	variable_name as string(RECORD_NAME_LEN)
	variable_type as string(1)
	variable_flag as string(NUM_OF_VARIABLE_FLAG)
end type


type command
	code as string(1)
	id as string(8)
	messageCode as string(1)
	operationCode as string(1)
	record as string(RECORD_NAME_LEN)
	context_name as string(CONTEXT_NAME_LEN)
end type

dim flag_addr as dword

dim agc as agg_context(MAX_ENTITY_NUM)
public dim age as agg_event(EVENT_TYPE_NUM)
dim agt as agg_table(TABLE_TYPE_NUM)
dim agv as agg_variable(MAX_VARIABLE_NUM)

dim agg_reconn_timer as byte
dim agg_login_rpl_timer as byte

public dim agg_connected as no_yes

public dim event_in_proc as no_yes
public dim agg_rec_num as word

dim agg_proc as agg_data_proc_phase
dim aggrx as string
dim cmd as command

declare function CallFunction(key_name as string(RECORD_NAME_LEN) ,context_name as string(CONTEXT_NAME_LEN), func_input as string, byref err as no_yes) as string


#if INSTANT_EVENT = YES
public dim agg_event_buff as string
#endif

#if STORED_EVENT = YES
public dim cur_event_tbl as string(MAX_TBL_NAME_LEN)
public dim event_found as boolean
#endif

#if TABLE_DATA = YES
dim cur_table_name as string(MAX_TBL_NAME_LEN)
#endif

#if STORED_EVENT = YES or TABLE_DATA = YES
'=============================================================
function agg_set_data_source(tbl_name as string, byref proc_rec_num as word) as ok_ng
'Descr: set pointer
	agg_set_data_source = NG
	if tbl_select(tbl_name) <> EN_TBL_STATUS_OK then exit function
	if tbl_record_find(no,"","",proc_rec_num,EN_TBL_SEARCH_DOWN,PL_FD_FIND_EQUAL) <> EN_TBL_STATUS_OK then exit function
	if tbl_record_ptr_sg(proc_rec_num,EN_TBL_SET) <> EN_TBL_STATUS_OK then exit function
	if tbl_record_sg(EN_TBL_GET) <> EN_TBL_STATUS_OK then exit function
	agg_set_data_source = OK
end function
#endif

#if TABLE_DATA = YES
'==================================================================
function agg_tbl_op_msg(tbl_result as en_tbl_status) as string
varify_result:
	select case tbl_result
		case EN_TBL_STATUS_OK: 
			agg_tbl_op_msg=""
		case EN_TBL_STATUS_FAILURE: 
			agg_tbl_op_msg=MSG_TBL_STATUS_FAILURE
		case EN_TBL_STATUS_UNKNOWN_TABLE: 
			agg_tbl_op_msg=MSG_TBL_STATUS_UNKNOWN_TABLE
		case EN_TBL_STATUS_UNKNOWN_FIELD: 
			agg_tbl_op_msg=MSG_TBL_STATUS_UNKNOWN_FIELD
		case EN_TBL_STATUS_INVALID: 
			agg_tbl_op_msg=MSG_TBL_STATUS_INVALID
		case EN_TBL_STATUS_FULL: 
			agg_tbl_op_msg=MSG_TBL_STATUS_FULL
		case EN_TBL_STATUS_KEY_VIOLATION
			agg_tbl_op_msg=MSG_TBL_STATUS_KEY_VIOLATION
	end select
end function

'=============================================================
function root_hash(byref context as string, byref err as no_yes) as string(64)
	dim sTemp1, sTemp2 as string(64)
	dim pos1,pos2 as byte
	dim tbl_result as en_tbl_status
	pos1 = instr(1,context,chr(ELEMENT_START),3)
	pos2 = instr(pos1,context,chr(ELEMENT_END),1)
	sTemp1 = mid(context,pos1+1,pos2-pos1-1)
	tbl_result = tbl_select(sTemp1)
	if tbl_result <> EN_TBL_STATUS_OK then
		root_hash = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if
	sTemp2 = tbl_get_hash()
	root_hash =chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+chr(ELEMENT_START)+sTemp2+chr(ELEMENT_END)+chr(ELEMENT_END)
	err = NO
end function

'=============================================================
function root_addRecord(byref context as string, byref err as no_yes) as string(64)
	dim sTemp1, sTemp2 as string(64)
	dim pos1,pos2 as byte
	dim table as tbl_type
	dim tbl_result as en_tbl_status
	dim i as byte
	dim md5_val as dword
	pos1 = instr(1,context,chr(ELEMENT_START),3)
	pos2 = instr(pos1,context,chr(ELEMENT_END),1)
	sTemp1 = mid(context,pos1+1,pos2-pos1-1)
	tbl_result = tbl_select(sTemp1)
	if tbl_result <> EN_TBL_STATUS_OK then 
		root_addRecord =  chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if
	tbl_get_tbl_info(table)

	pos1 = instr(pos2,context,"%<I%=",1)+5
	pos2 = instr(pos1,context,"%>",1)
	sTemp2 = mid(context,pos1,pos2-pos1)
	tbl_result = tbl_field_sg("UID",sTemp2,EN_TBL_SET)
	if tbl_result <> EN_TBL_STATUS_OK then 
		root_addRecord =  chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if
	i=0
	while true
		pos1 = instr(pos2,context,"%<",1)
		pos2 = instr(pos1,context,"%>",1)
		if pos1 > 0 and pos2 > 0 then
			sTemp2 = mid(context,pos1+2,pos2-pos1-2)
			tbl_result = tbl_field_sg(table.Fields(i).FieldName,sTemp2,EN_TBL_SET)
			if tbl_result <> EN_TBL_STATUS_OK then
				root_addRecord = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+"("+table.Fields(i).FieldName+")"+chr(ELEMENT_END)
				if tbl_result = EN_TBL_STATUS_INVALID then
					if table.Fields(i).FieldType =`S` then
						root_addRecord =  chr(ELEMENT_START)+"Field length invalid"+"("+table.Fields(i).FieldName+")"+chr(ELEMENT_END)
					else
						root_addRecord =  chr(ELEMENT_START)+"Field value is not within vaild range"+"("+table.Fields(i).FieldName+")"+chr(ELEMENT_END)
					end if
				end if
				err = YES
				exit function
			end if
			i = i+1
		else 
			exit while
		end if
	wend
	md5_val = tbl_set_md5()
	tbl_result = tbl_record_add()
	if tbl_result <> EN_TBL_STATUS_OK then 
		root_addRecord =  chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if
	tbl_mod_HASH(md5_val)
	err = NO
	root_addRecord = ""
end function

'=============================================================
function root_putRecord(byref context as string, byref err as no_yes) as string(64)
	dim sTemp1 as string(64)
	dim pos1,pos2 as byte
	dim table as tbl_type
	dim tbl_result as en_tbl_status
	dim i as byte
	dim md5_val as dword
	tbl_select("TBL_TEMP")
	tbl_get_tbl_info(table)
	
	pos1 = instr(1,context,"%<I%=",1)+5
	pos2 = instr(pos1,context,"%>",1)
	sTemp1 = mid(context,pos1,pos2-pos1)
	tbl_result = tbl_field_sg("UID",sTemp1,EN_TBL_SET)
	if tbl_result <> EN_TBL_STATUS_OK then 
		root_putRecord =  chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if

	i=0
	while true
		pos1 = instr(pos2,context,"%<",1)
		pos2 = instr(pos1,context,"%>",1)
		if pos1 > 0 and pos2 > 0 then
			sTemp1 = mid(context,pos1+2,pos2-pos1-2)
			tbl_result = tbl_field_sg(table.Fields(i).FieldName,sTemp1,EN_TBL_SET)
			if tbl_result <> EN_TBL_STATUS_OK then
				root_putRecord = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+"("+table.Fields(i).FieldName+")"+chr(ELEMENT_END)
				if tbl_result = EN_TBL_STATUS_INVALID then
					if table.Fields(i).FieldType =`S` then
						root_putRecord =  chr(ELEMENT_START)+"Field length invalid"+"("+table.Fields(i).FieldName+")"+chr(ELEMENT_END)
					else
						root_putRecord =  chr(ELEMENT_START)+"Field value is not within vaild range"+"("+table.Fields(i).FieldName+")"+chr(ELEMENT_END)
					end if
				end if
				err = YES
				exit function
			end if
			i = i+1
		else 
			exit while
		end if
	wend
	md5_val = tbl_set_md5()
	tbl_result = tbl_record_add()
	if tbl_result <> EN_TBL_STATUS_OK then 
		root_putRecord =  chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if
	tbl_mod_HASH(md5_val)
	root_putRecord = ""
	err = NO
end function

'=============================================================
function root_updateRecord(byref context as string, byref err as no_yes) as string(64)
	dim sTemp1, sTemp2 as string(64)
	dim pos1,pos2 as byte
	dim table as tbl_type
	dim i as byte
	dim msw, lsw as word
	dim tbl_result as en_tbl_status
	
	pos1 = instr(1,context,chr(ELEMENT_START),3)
	pos2 = instr(pos1,context,chr(ELEMENT_END),1)
	sTemp1 = mid(context,pos1+1,pos2-pos1-1)
	tbl_result= tbl_select(sTemp1)
	if tbl_result <> EN_TBL_STATUS_OK then
		root_updateRecord = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if
	tbl_get_tbl_info(table)
	pos1 = instr(pos2,context,"%<I%=",1)+5
	pos2 = instr(pos1,context,"%>",1)
	sTemp2 = mid(context,pos1,pos2-pos1)
	msw = lval(sTemp2)/65536
	lsw = lval(sTemp2) mod 65536
	sTemp2 = chr(msw/256)+chr(msw mod 256)+chr(lsw/256)+chr(lsw mod 256)
	tbl_result = tbl_record_find(NO,sTemp2,"UID",1,EN_TBL_SEARCH_DOWN,PL_FD_FIND_EQUAL)
	if tbl_result <> EN_TBL_STATUS_OK then
		root_updateRecord = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if	
	tbl_result = tbl_record_sg(EN_TBL_GET)
	if tbl_result <> EN_TBL_STATUS_OK then
		root_updateRecord = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if
	tbl_mod_HASH(tbl_set_md5())
	i=0
	while true
		pos1 = instr(pos2,context,"%<",1)
		pos2 = instr(pos1,context,"%>",1)
		if pos1 > 0 and pos2 > 0 then
			sTemp2 = mid(context,pos1+2,pos2-pos1-2)
			tbl_result = tbl_field_sg(table.Fields(i).FieldName,sTemp2,EN_TBL_SET)
			if tbl_result <> EN_TBL_STATUS_OK then
				root_updateRecord = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+"("+table.Fields(i).FieldName+")"+chr(ELEMENT_END)
				if tbl_result = EN_TBL_STATUS_INVALID then
					if table.Fields(i).FieldType =`S` then
						root_updateRecord =  chr(ELEMENT_START)+"Field length invalid"+"("+table.Fields(i).FieldName+")"+chr(ELEMENT_END)
					else
						root_updateRecord =  chr(ELEMENT_START)+"Field value is not within vaild range"+"("+table.Fields(i).FieldName+")"+chr(ELEMENT_END)
					end if
				end if
				err = YES
				exit function
			end if

			i = i+1
		else 
			exit while
		end if
	wend
	tbl_result = tbl_record_sg(EN_TBL_SET)
	if tbl_result <> EN_TBL_STATUS_OK then 
		root_updateRecord =  chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if
	tbl_mod_HASH(tbl_set_md5())
	root_updateRecord = ""
	err = NO
end function

'=============================================================
function root_removeRecord(byref context as string, byref err as no_yes) as string(64)
	dim sTemp1, sTemp2 as string(64)
	dim pos1,pos2 as byte
	dim i as byte
	dim msw, lsw as word
	dim tbl_result as en_tbl_status
	dim md5_val as dword
	pos1 = instr(1,context,chr(ELEMENT_START),3)
	pos2 = instr(pos1,context,chr(ELEMENT_END),1)
	sTemp1 = mid(context,pos1+1,pos2-pos1-1)
	tbl_result = tbl_select(sTemp1)
	if tbl_result <> EN_TBL_STATUS_OK then
		root_removeRecord = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if

	pos1 = instr(pos2,context,chr(ELEMENT_START),1)
	pos2 = instr(pos1,context,chr(ELEMENT_END),1)
	sTemp2 = mid(context,pos1+1,pos2-pos1-1)
	msw = lval(sTemp2)/65536
	lsw = lval(sTemp2) mod 65536
	sTemp2 = chr(msw/256)+chr(msw mod 256)+chr(lsw/256)+chr(lsw mod 256)
	tbl_result = tbl_record_find(NO,sTemp2,"UID",1,EN_TBL_SEARCH_DOWN,PL_FD_FIND_EQUAL)
	if tbl_result = EN_TBL_STATUS_OK then 
		tbl_record_sg(EN_TBL_GET)
		md5_val = tbl_set_md5()
		tbl_result = tbl_record_delete()
		if tbl_result <> EN_TBL_STATUS_OK then
			root_removeRecord = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
			err = YES
			exit function
		end if		
		tbl_mod_HASH(md5_val)
	else
		root_removeRecord = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if
	root_removeRecord = ""
	err = NO
end function

'=============================================================
function root_startTable(context as string, byref err as no_yes) as string(64)
	dim sTemp1 as string(64)
	dim pos1,pos2 as byte
	dim tbl_result as en_tbl_status
	
	tbl_select("TBL_TEMP")
	tbl_result = tbl_delete()
	if tbl_result <> EN_TBL_STATUS_OK then
		root_startTable = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if		
	pos1 = instr(1,context,chr(ELEMENT_START),3)
	pos2 = instr(pos1,context,chr(ELEMENT_END),1)
	sTemp1 = mid(context,pos1+1,pos2-pos1-1)
	cur_table_name=sTemp1
	tbl_result = tbl_select(sTemp1)
	if tbl_result <> EN_TBL_STATUS_OK then
		root_startTable = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if		

	tbl_copy_info(cur_table_name,"TBL_TEMP")
	root_startTable = ""
	err = NO
end function

'=============================================================
function root_finishTable(byref err as no_yes) as string(64)
	dim tbl_result as en_tbl_status
	tbl_result = tbl_replace(cur_table_name,"TBL_TEMP")
	if tbl_result <> EN_TBL_STATUS_OK then
		root_finishTable = chr(ELEMENT_START)+agg_tbl_op_msg(tbl_result)+chr(ELEMENT_END)
		err = YES
		exit function
	end if
	root_finishTable = ""
	err = NO
end function

#endif

'==================================================================
sub agg_sg_systime(byref date_time as string(23), op as en_device_rdwr)
'set or get the rtc time by aggregate command.
	dim syear as string(4)
	dim smonth, sdate, shour, smin, ssec as string(2)
	dim wdaycount, wmincount as word
	dim bsec as byte
'GET the RTC time
	if op = DEVICE_GET then
		rtc.getdata(wdaycount,wmincount,bsec)
		CovertTimeType(date_time,wdaycount,wmincount,bsec,TIME_TO_STR)
		TimeFormatStyle(date_time,0,op)
		
	else
'Set the RTC time
	TimeFormatStyle(date_time,0,op)
	CovertTimeType(date_time,wdaycount,wmincount,bsec,STR_TO_TIME)
	rtc.setdata(wdaycount,wmincount,bsec)
	end if
end sub

'==================================================================
function agg_element_extract(byref pos as byte, byref length as byte, search_str as string(5), byref element_str as string, byref count as byte) as string
	dim p1, p2, p3 as byte
	dim s as string
	dim s1 as string(1)
	
	if search_str = "" then
		search_str = chr(ELEMENT_START)
	end if
	if count = 0 then
		pos = instr(pos,element_str, search_str,1)
		if pos > 0 then 
			count = 1
		else
			agg_element_extract = ""
			exit function
		end if
	end if

	p3 = pos+1
	while count > 0 
		p1 = instr(p3,element_str,chr(ELEMENT_START),1)
		p2 = instr(p3,element_str,chr(ELEMENT_END),1)
		if p1 = 0 then
			if count > 0 then 
				p1 = 255
			else
				if p2 > 0 then 
					count = count +1
					length = p2-pos+1
				end if
				agg_element_extract = ""
				exit function
			end if
		end if
		if p1 < p2 then
			p3 = p1+1
			count = count+1
		else
			if p2 = 0 then
				if p1 > 0 then 
					count = count+1
					length = p1-pos+1
				end if
				agg_element_extract = ""
				exit function
			end if		
			p3 = p2+1
			count = count-1
		end if
	wend
	length = p3-pos
	s = mid(element_str,pos,length)
	agg_element_extract = s
end function

'==================================================================
function agg_hex_to_hexstr(byref is as string) as string
	dim ss as string(4)
	dim f as byte

	agg_hex_to_hexstr=""
	for f=1 to len(is)
		ss=hex(asc(mid(is,f,1)))
		ss=right(ss,len(ss)-2)
		if len(ss)<2 then
			ss="0"+ss
		end if
		agg_hex_to_hexstr=agg_hex_to_hexstr+ss
	next f
end function

'==================================================================
function root_login(byref context as string, byref err as no_yes) as string(64)
	dim sTemp1,sTemp2,sTemp3 as string(64)
	dim pos1,pos2 as byte

	context = agg_element_extract(4,"",chr(ELEMENT_START),context,0)
	if setting_sg("ON",0,sTemp1,EN_STG_GET) <> EN_STG_STATUS_OK then
		root_login=chr(ELEMENT_START)+SETTING_GET_FAIL+"(Owner Name)"+chr(ELEMENT_END)
		err = YES
	end if
	sTemp2 = chr(ELEMENT_START)+sTemp1+chr(ELEMENT_END)
	if setting_sg("DN",0,sTemp1,EN_STG_GET) <> EN_STG_STATUS_OK then
		root_login=chr(ELEMENT_START)+SETTING_GET_FAIL+"(Device Name)"+chr(ELEMENT_END)
		err = YES
	end if
	
	sTemp2 = sTemp2 + chr(ELEMENT_START)+sTemp1+chr(ELEMENT_END)
	pos1 = instr(1,context,chr(ELEMENT_START),1)
	pos2 = instr(pos1,context,chr(ELEMENT_END),1)
	sTemp3 = mid(context,pos1+1,pos2-pos1-1)
	if setting_sg("PW",0,sTemp1,EN_STG_GET) <> EN_STG_STATUS_OK then
		root_login=chr(ELEMENT_START)+SETTING_GET_FAIL+"(Password)"+chr(ELEMENT_END)
		err = YES
	end if
	sTemp3 = sTemp3+sTemp1
	sTemp1=md5(sTemp3,"",MD5_FINISH,len(sTemp3))
	sTemp3 = agg_hex_to_hexstr(sTemp1)
	sTemp2 = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+sTemp2+chr(ELEMENT_START)+sTemp3+chr(ELEMENT_END)+chr(ELEMENT_END)
	root_login = sTemp2
	err = NO
	login(CMD_MODE_AGGREGATE,"",SOCK_LS)

end function

'=============================================================
function agg_func_result(operation as string(1), op_result as string(1), byref err as no_yes) as string(50)
	select case operation
	case "Z": 
		agg_func_result = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+chr(ELEMENT_START)+SYS_DOOR_OPEN+chr(ELEMENT_END)+chr(ELEMENT_END)
		err = NO
	case "J":
		select case op_result
		case "A": 
			agg_func_result = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+chr(ELEMENT_START)+MSG_TBL_TABLE_DELETED+chr(ELEMENT_END)+chr(ELEMENT_END)
			err = NO
		case else: 			
			agg_func_result = chr(ELEMENT_START)+MSG_TBL_FAIL_DELETE_TABLE+chr(ELEMENT_END)
			err = YES
		end select
	case "M":
		select case op_result
		case "A": 
			agg_func_result = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+chr(ELEMENT_START)+SYS_INFO_FD_FORMAT+chr(ELEMENT_END)+chr(ELEMENT_END)
			err = NO
		case else: 
			agg_func_result =chr(ELEMENT_START)+SYS_ERROR_FD+chr(ELEMENT_END)
			err = YES
		end select
	end select
end function


'=============================================================
function root_operation(byref op as string(RECORD_NAME_LEN), byref context as string, byref err as no_yes) as string(64)
'These are pre-defined Aggregate function calls that have to added to the root level, so the Table data synchronization would work properly
	dim s as string
	select case op
		case "synchronized":
			agg_connected = YES
			root_operation = ""
			err = NO
#if STORED_EVENT = YES
'---------- look for events ------------
	dim i as byte
	event_found = false
	for i = 0 to EVENT_TYPE_NUM-1
		if tbl_select(age(i).event_name) = EN_TBL_STATUS_OK and tbl_record_find(no,"","",1,EN_TBL_SEARCH_DOWN,PL_FD_FIND_EQUAL) = EN_TBL_STATUS_OK then
			event_found = true
			exit for
		end if		
	next i
#endif

#if TABLE_DATA = YES
		case "hash":
			'returns hash value of the table
			root_operation=root_hash(context,err)
			exit function
		case "startTable":
			'start table synchronization, this function call info device to start replace the whole table
			root_operation = root_startTable(context, err)
		case "finishTable":
			'this function call notify the device that the table synchronization is done.
			root_operation=root_finishTable(err)
			if err = YES then exit function
			root_operation=root_hash(context,err)
			exit function
		case "addRecord":
			'adding single record to the target table
			root_operation = root_addRecord(context,err)
		case "removeRecord":
			'remove single record from the target table
			root_operation = root_removeRecord(context,err)
		case "updateRecord":
			'modify a single record which is pointed by the table record pointer.
			root_operation = root_updateRecord(context,err)						
		case "putRecords":
			'this is the function call used to add records to device during total table synchronization.
			root_operation = root_putRecord(context,err)
#endif
		case "login":
			root_operation = root_login(context,err)
			exit function
		case "register":
			if setting_get("AR",0) = "1" then
				s = setting_get("PW",0)
				root_operation = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+chr(ELEMENT_START)+s+chr(ELEMENT_END)+chr(ELEMENT_END)
				err = NO
				exit function 
			else
				root_operation = chr(ELEMENT_START)+"Auto Register Disabled"+chr(ELEMENT_END)
				err = YES
			end if
		case "buzz":
			device_operation("B")
			root_operation = ""
			err = NO
		case "init":
			s = "The device is rebooting after initialization!"
			root_operation = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+chr(ELEMENT_START)+s+chr(ELEMENT_END)+chr(ELEMENT_END)
			err = NO
			exit function
		case "reboot":
			s = "The device is rebooting"
			root_operation = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+chr(ELEMENT_START)+s+chr(ELEMENT_END)+chr(ELEMENT_END)
			err = NO
			exit function
		case else
			context = device_operation(op)
			root_operation = agg_func_result(op,context, err)
			exit function
	end select
end function

'=============================================================
sub Invisible_Separators(byref s as string)
	device_replace_chr(s,"<",chr(ELEMENT_START))
	device_replace_chr(s,">",chr(ELEMENT_END))
	device_replace_chr(s,"=",chr(ELEMENT_NAME_VALUE_SEPARATOR))
	device_replace_chr(s,"^",chr(TABLE_NULL))
end sub

'=============================================================
sub aggregate_send(s as string)
	sock.num = SOCK_LS
	sock.setdata(s)
	sock.send
end sub
'=============================================================
sub Mem_Struct_Fill(script_file as string, byref mem_struct as agg_context(MAX_ENTITY_NUM), max_count as byte)
'Search through the romfile and store the address of records in the array for later fast access 

	dim s as string
	dim i, line_end as word
	dim num_agc, j, k as byte
	k = 0
	j = 0
	
	num_agc=0 'will count settings (starting from 0)
	romfile.open(script_file)				'this file is a setting descriptor table
	i=romfile.find(romfile.pointer,"::",1)
	while i<>0
		'we are now at the "::" pointing at the beginning of one setting descriptor line
		romfile.pointer=i+2
		
		'find the end of this setting descriptor line
		line_end=romfile.find(romfile.pointer,chr(END_OF_LINE),1)
		
		'extract entity name
		do
			i=romfile.find(romfile.pointer,chr(FIELD_SEPARATOR),1) 
			s=romfile.getdata(i-romfile.pointer)
			romfile.pointer=i+1
		loop while s="" 		
		
		if len(s) > RECORD_NAME_LEN then sys.halt 'the key name is too long
		mem_struct(num_agc).key_name = s
		
		'extract setting type
		do
			i=romfile.find(romfile.pointer,chr(FIELD_SEPARATOR),1) 	
			s=romfile.getdata(i-romfile.pointer)
			romfile.pointer=i+1
		loop while s=""
		if s = "root" then s = ""
		mem_struct(num_agc).context_name = s
		
		'extract the number of members
		do
			i=romfile.find(romfile.pointer,chr(FIELD_SEPARATOR),1) 
			if i > line_end then i = line_end			
			mem_struct(num_agc).romaddr_def=romfile.pointer
			s=romfile.getdata(i-romfile.pointer)
			romfile.pointer=i+1
			if romfile.pointer > line_end then exit do
			if left(s,2) <> "<R" then s=""
		loop while s="" 		
		
		' move to next one
		i=romfile.find(line_end,"::",1)
		num_agc=num_agc+1
	
		'exceeded the max lines of scripts?
		if num_agc>=max_count and i<>0 then
			sys.halt
			num_agc=0 'you need to increase MAX_ENTITY_NUM!
		end if
	wend
end sub

'=============================================================
public sub AggreGateInit
'Descr: AggreGate agent initialization
'Read from the AggreGate Script files and fill up the address table for main script, event script and function script 
	dim i, j, k,l,m, pos,p,q,r as byte
	dim romaddr_start, romaddr_end, romaddr_mid, romaddr_header as word
	dim s as string
	dim stemp1, stemp2 as string(64)
	
	
	sock.num = SOCK_LS
	sock.protocol=PL_SOCK_PROTOCOL_TCP
	sock.connectiontout=val(setting_get("CT",0)) * 60 * 2
	sock.targetip=setting_get("DI",0) ' Get IP setting here
	sock.targetport=val(setting_get("DP",0))
	sock.txbuffrq(2)
	sock.rxbuffrq(2)
	sys.buffalloc
	
 	Mem_Struct_Fill(LS_MAIN_SCRIPT,agc, MAX_ENTITY_NUM)
	j = 0
	k = 0

	for i = 0 to MAX_ENTITY_NUM - 1
		if agc(i).key_name = "events" then
			if EVENT_TYPE_NUM > 0 then
				romfile.open(LS_MAIN_SCRIPT)
				romaddr_start = agc(i).romaddr_def
				romaddr_end = romfile.find(romaddr_start,chr(END_OF_LINE),1)			
				for j = 0 to EVENT_TYPE_NUM -1
					romaddr_header = romaddr_start-1
					do
						romaddr_header = romaddr_header-1
						if romfile.find(romaddr_header,chr(TAB),1) <> romaddr_header and romfile.find(romaddr_header,"~",1) <> romaddr_header then 
							do
								romaddr_header = romaddr_header-1
								if romfile.find(romaddr_header,chr(TAB),1) = romaddr_header then goto found_flag
							loop while true
						end if
					loop while true
found_flag:			romaddr_header = romaddr_header+1
					romfile.pointer = romaddr_header
					stemp2 = romfile.getdata(romaddr_start-romaddr_header)
					pos=instr(1,stemp2,chr(COMMA),1)
					if mid(stemp2,pos+1,1) = "Y" then 
						age(j).disk_event = true 
					else
						age(j).disk_event = false
					end if
					
					age(j).context_name = agc(i).context_name
					romfile.pointer = romaddr_start
					s = romfile.getdata(romaddr_end-romaddr_start)
					Invisible_Separators(s)
					pos = 4
					stemp1 = agg_element_extract(pos,l,"",s,0)
					age(j).event_name = mid(stemp1,2,l-2)
					pos = pos+l+1
					while true
						stemp1 = agg_element_extract(pos,l,"",s,0)
						pos = pos+l
						if mid(stemp1,2,1)<>chr(ELEMENT_START) then 
							exit while
						else
							stemp1 = agg_element_extract(2,l,"",stemp1,0)
							stemp1 = mid(stemp1,2,l-2)
							age(j).event_fields(k) = stemp1
							k = k+1
						end if
					wend
					stemp1 = agg_element_extract(pos,l,"",s,0)
					pos = pos+l
					stemp1 = agg_element_extract(pos,l,"",s,0)
					pos = pos+l
					stemp1 = agg_element_extract(pos,l,"",s,0)
					pos = pos+l
					stemp1 = agg_element_extract(pos,l,"",s,0)
					pos = pos+l				
					stemp1 = mid(stemp1,2,l-2)
					age(j).event_level = stemp1
					romaddr_start = romfile.find(romaddr_end,"~~",1)
					if romaddr_start > 0 then 
						romaddr_start= romaddr_start+2
						romaddr_end = romfile.find(romaddr_start,chr(END_OF_LINE),1)
						k=0
					end if
				next j
			end if
		end if
	next i
	j = 0
	k = 0
	for i = 0 to MAX_ENTITY_NUM - 1
		if agc(i).key_name = "variables" then
			
			romfile.open(LS_MAIN_SCRIPT)
			romaddr_start = agc(i).romaddr_def
			if i < MAX_ENTITY_NUM-1 then 
				romaddr_end = agc(i+1).romaddr_def
			else
				romaddr_end = romfile.size
			end if
			r = 0
			do
				romaddr_mid = romfile.find(romaddr_start,chr(END_OF_LINE),1)
				romfile.pointer = romaddr_start
				s = romfile.getdata(romaddr_mid-romaddr_start)
				Invisible_Separators(s)
				stemp1 = agg_element_extract(4,l,"",s,0)
				stemp1 = mid(stemp1,2,l-2)
				
				if stemp1 <> "modtime" and stemp1 <>"date" and stemp1 <> "version" then
					romaddr_header = romaddr_start
					do
						romaddr_header = romaddr_header-1
						if romfile.find(romaddr_header,chr(END_OF_LINE),1) = romaddr_header then exit do
					loop while true
					romfile.pointer = romaddr_header+2
					stemp2 = romfile.getdata(romaddr_start-romaddr_header)
					for p = 1 to len(stemp2)
						if mid(stemp2,p,1)<>chr(TAB) then exit for
					next p
					stemp2 = right(stemp2,len(stemp2)-p+1)
					p = instr(1,stemp2,chr(COMMA),1)
					if p = 0 then goto next_variable
					agv(r).variable_name = mid(stemp2,1,p-1)
					q = p+1
					p = instr(q,stemp2,chr(COMMA),1)
					agv(r).variable_type = mid(stemp2,q,p-q)
					q = p+1
					p = instr(q,stemp2,chr(TAB),1)
					agv(r).variable_flag = mid(stemp2,q,p-q)				
					if agv(r).variable_type= "T" then
						agt(j).table_name = agv(r).variable_name
						agt(j).context_name = agc(i).context_name
						pos = l+5
						while true
							stemp1 = agg_element_extract(pos,m,"",s,0)
							if mid(stemp1,2,1)<>chr(ELEMENT_START) then 
								exit while
							else
								stemp1 = agg_element_extract(2,l,"",stemp1,0)
								agt(j).table_fields(k) = mid(stemp1,2,l-2)
								k = k+1
							end if
							pos = pos+m
						wend
						j= j+1
					end if
					r = r+1
				end if
next_variable:
				romaddr_mid = romfile.find(romaddr_start,"~~",1)
				romaddr_start = romaddr_mid+2
			loop while  romaddr_mid < romaddr_end and romaddr_mid > 0
		end if
	next i

#if STORED_EVENT = YES
'---------- look for events ------------
	event_found = false
	for i = 0 to EVENT_TYPE_NUM-1
		if tbl_select(age(i).event_name) = EN_TBL_STATUS_OK and tbl_record_find(no,"","",1,EN_TBL_SEARCH_DOWN,PL_FD_FIND_EQUAL) = EN_TBL_STATUS_OK then
			event_found = true
			exit for
		end if		
	next i
#endif
'---------- Event handle by device ---------------
	agg_reconn_timer = 0
	agg_connected = NO
	agg_login_rpl_timer = 0
end sub

'=============================================================
function GetNumAgc(key_name as string(RECORD_NAME_LEN), context_name as string(CONTEXT_NAME_LEN), byref mem_struct as agg_context(MAX_ENTITY_NUM), max_count as byte)as byte
'Descr: Find the index of record in the address table

	dim i as byte 
	for i = 0 to max_count - 1
		if mem_struct(i).key_name = key_name and mem_struct(i).context_name = context_name then 
			GetNumAgc = i
			exit function
		end if
	next i
	GetNumAgc = 255
end function


'=============================================================
sub Proc_Variable(cmd as command)
	dim num_agc as byte
	dim romaddr_start, romaddr_end, romaddr_mid, rec_num as word
	dim s as string
	dim stemp1, stemp2 as string(64)
	dim pos1, i, j as byte
	select case cmd.record
	case "modtime":
		s = chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(COMMAND_PARAMETERS_SEPARATOR)
		aggregate_send(s)
		for i = 0 to MAX_VARIABLE_NUM-1	
			stemp1 = agv(i).variable_name
			if stemp1 <> "" and left(agv(i).variable_flag,1) = "Y" then
				device_modtime_sg(sTemp2,stemp1,DEVICE_GET)
				s = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+chr(ELEMENT_START)+stemp1+chr(ELEMENT_END)+chr(ELEMENT_START)+stemp2+chr(ELEMENT_END)+chr(ELEMENT_END)
				aggregate_send(s)
			end if
		next i
		s = chr(COMMAND_END)
		aggregate_send(s)
		exit sub
	case "version":
		sTemp1 = FIRMWARE_VERSION
		sTemp1 = mid(sTemp1,3,len(sTemp1)-3)
		s = chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(COMMAND_PARAMETERS_SEPARATOR)
		s = s+chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+chr(ELEMENT_START)+stemp1+chr(ELEMENT_END)+chr(ELEMENT_END)+chr(COMMAND_END)
		aggregate_send(s)
	case "date":
		agg_sg_systime(sTemp1,DEVICE_GET)
		sTemp1 = sTemp1+".000"
		s = chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(COMMAND_PARAMETERS_SEPARATOR)
		s = s+chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+chr(ELEMENT_START)+stemp1+chr(ELEMENT_END)+chr(ELEMENT_END)+chr(COMMAND_END)
		aggregate_send(s)	
	case else
		if setting_sg(cmd.record,0,stemp1,EN_STG_GET) = EN_STG_STATUS_OK then
			s = chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(COMMAND_PARAMETERS_SEPARATOR)			
			s = s+chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+chr(ELEMENT_START)+stemp1+chr(ELEMENT_END)+chr(ELEMENT_END)+chr(COMMAND_END)
			aggregate_send(s)

		else
#if TABLE_DATA = YES
			rec_num = 1
			for i = 0 to TABLE_TYPE_NUM-1
				if agt(i).table_name = cmd.record then
					aggregate_send(chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(COMMAND_PARAMETERS_SEPARATOR))
					do
						if agg_set_data_source(cmd.record,rec_num) <> OK or rec_num = 0 then exit do
						s = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)
						if tbl_field_sg("UID",stemp1,EN_TBL_GET) <> EN_TBL_STATUS_OK then exit for
						s = s + chr(ELEMENT_START)+"I"+chr(ELEMENT_NAME_VALUE_SEPARATOR)+stemp1+chr(ELEMENT_END)
						for j = 0 to TABLE_FIELD_NUM-1
							if tbl_field_sg(agt(i).table_fields(j),stemp1,EN_TBL_GET) <> EN_TBL_STATUS_OK then exit for
							s = s + chr(ELEMENT_START)+stemp1+chr(ELEMENT_END)
						next j
						s = s+chr(ELEMENT_END)
						aggregate_send(s)
						rec_num = rec_num+1
					loop while true
					aggregate_send(chr(COMMAND_END))
					exit sub
				end if
			next i
#endif
			s = chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"E"+chr(COMMAND_PARAMETERS_SEPARATOR)+"Unable to find the variable"+chr(COMMAND_END)
			aggregate_send(s)
		end if
	end select
end sub

'=============================================================
function CallFunction(key_name as string(RECORD_NAME_LEN) ,context_name as string(CONTEXT_NAME_LEN), func_input as string, byref err as no_yes) as string
	dim s as string
	device_sys_busy(yes)
	if len(func_input) > 0 then
		s = key_name+mid(func_input,2,len(func_input)-2)
	else 
		s = key_name
	end if
	
	Select case context_name
	case "":
		CallFunction = root_operation(key_name,func_input, err)
	end select
	device_sys_busy(no)
end function

'=============================================================
function aggrx_getdata(substr as string) as string
	dim x as byte
	sock.num = SOCK_LS
	aggrx = aggrx+sock.getdata(255-len(aggrx))
	x=instr(1,aggrx,substr,1)
	if x>0 then
		aggrx_getdata=left(aggrx,x-1)
		aggrx=right(aggrx,len(aggrx)-x)
	else
		aggrx_getdata = ""
	end if
end function

'=============================================================
sub aggrx_remove(l as byte)
	if l > 0 then 
		sock.num = SOCK_LS
		aggrx = right(aggrx,len(aggrx)+1-l)
		aggrx = aggrx+sock.getdata(255-len(aggrx))
	end if
end sub
'=============================================================
public sub ProcessCommand
'Descr: Process commands from AggreGate server.  
	dim pos1, pos2, l as byte
	dim s as string
	dim field_name as string(RECORD_NAME_LEN)
	dim stemp1 as string(64)
	dim num_agc as byte
	dim romaddr_start, romaddr_end, romaddr_mid, romaddr_nl as word
	dim err as no_yes
	dim result as en_stg_status
	
	agg_login_rpl_timer = AGG_RPL_WAIT_TIME
	romfile.open(LS_MAIN_SCRIPT)
	while true
		select case agg_proc
		case AGG_IDLE_PHASE:
			aggrx_getdata("")
			pos1 = instr(1,aggrx,chr(COMMAND_START),1)
			aggrx_getdata(chr(COMMAND_START))
			if pos1 > 0 then
				agg_proc = AGG_TYPE_PHASE
			else
				if len(aggrx)=255 then 
					aggrx = ""
					exit sub
				end if
			end if
		case AGG_TYPE_PHASE:
			stemp1 = aggrx_getdata(chr(COMMAND_PARAMETERS_SEPARATOR))
			if stemp1 <> "" then
				cmd.code = stemp1
				agg_proc = AGG_ID_PHASE
			else
				agg_proc = AGG_IDLE_PHASE
			end if
		case AGG_ID_PHASE:
			stemp1 = aggrx_getdata(chr(COMMAND_PARAMETERS_SEPARATOR))
			if stemp1 <> "" then
				cmd.id = stemp1
				agg_proc = AGG_OP_PHASE
			else
				agg_proc = AGG_IDLE_PHASE
			end if
		case AGG_OP_PHASE:
			stemp1 = aggrx_getdata(chr(COMMAND_PARAMETERS_SEPARATOR))
			if stemp1 <> "" then
				cmd.messageCode = stemp1
				select case cmd.messageCode
				case "S":
					s = chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(COMMAND_END)
					aggregate_send(s)
					pos2 = instr(1,aggrx,chr(COMMAND_END),1)
					aggrx_remove(pos2)
					agg_proc = AGG_IDLE_PHASE
					exit sub
				case "O":
					agg_proc = AGG_SGC_PHASE
				end select
			else
				agg_proc = AGG_IDLE_PHASE
			end if
		case AGG_SGC_PHASE:		
			stemp1 = aggrx_getdata(chr(COMMAND_PARAMETERS_SEPARATOR))
			if stemp1 <> "" then
				cmd.operationCode = stemp1
				agg_proc = AGG_ENTITY_PHASE
			else
				agg_proc = AGG_IDLE_PHASE
			end if

		case AGG_ENTITY_PHASE:
			stemp1 = aggrx_getdata(chr(COMMAND_PARAMETERS_SEPARATOR))
			cmd.context_name = stemp1
			agg_proc = AGG_RECORD_PHASE
				
		case AGG_RECORD_PHASE:
			select case cmd.operationCode
			case "S":
				stemp1 = aggrx_getdata(chr(COMMAND_PARAMETERS_SEPARATOR))
			case "G":
				stemp1 = aggrx_getdata(chr(COMMAND_END))
			case "C":
				stemp1 = aggrx_getdata(chr(COMMAND_PARAMETERS_SEPARATOR))		
			end select
			if stemp1 <> "" then
				cmd.record = stemp1
				agg_proc = AGG_DATA_PHASE
			else
				agg_proc = AGG_IDLE_PHASE
			end if
		case AGG_DATA_PHASE:
		select case cmd.operationCode
			case "G":
				aggrx_getdata(chr(COMMAND_END))
				num_agc = GetNumAgc(cmd.record, cmd.context_name,agc,MAX_ENTITY_NUM)
				if num_agc = 255 then
					proc_variable(cmd)
					agg_proc = AGG_IDLE_PHASE
					exit sub
				end if
				romaddr_start = agc(num_agc).romaddr_def
				romaddr_end = romfile.find(romaddr_start,chr(END_OF_LINE),1)
				romaddr_nl = romfile.find(romaddr_start,chr(NEW_LINE),1)
				if romaddr_nl < romaddr_end then 
					s = ""
				else
					romfile.pointer = romaddr_start
					s = romfile.getdata(romaddr_end-romaddr_start)
					invisible_separators(s)
				end if
				s = chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(COMMAND_PARAMETERS_SEPARATOR)+s
				aggregate_send(s)
				s = ""
				romaddr_mid = romfile.find(romaddr_start,"~~",1)
				if num_agc < MAX_ENTITY_NUM-1 then 
					romaddr_end = agc(num_agc+1).romaddr_def
				else
					romaddr_end = romfile.size
				end if
				while  romaddr_mid < romaddr_end and romaddr_mid > 0
					romaddr_start = romaddr_mid+2
					romaddr_mid = romfile.find(romaddr_start,chr(END_OF_LINE),1)
					romfile.pointer = romaddr_start
					s = romfile.getdata(romaddr_mid-romaddr_start)
					invisible_separators(s)
					aggregate_send(s)
					s = ""
					romaddr_mid = romfile.find(romaddr_start,"~~",1)
					if romaddr_mid = 0 then exit while
				wend 
				s = chr(COMMAND_END)
				agg_proc = AGG_IDLE_PHASE
				aggregate_send(s)
				exit sub
			case "S":
					pos1 = 1
rx_read:
					stemp1 = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)
					s = agg_element_extract(pos1,l,stemp1,aggrx,0)
					aggrx_remove(pos1+l-1)
					if pos1 > 0 then
						select case cmd.record
						case "date":		'set date
							pos1 = 4
							s = agg_element_extract(pos1,l,"",s,0)
							s = mid(s,2,l-2)
							agg_sg_systime(s,DEVICE_SET)
						case "modtime":		'set modification time
							do
								pos1 = 4
								stemp1 = agg_element_extract(pos1,l,"",s,0)
								field_name = mid(stemp1,2,l-2)
								pos1 = l+4
								stemp1 = agg_element_extract(pos1,l,"",s,0)
								stemp1 = mid(stemp1,2,l-2)
								device_modtime_sg(stemp1,field_name,DEVICE_SET)			
								pos1 = 1
								stemp1 = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)
								s = agg_element_extract(pos1,l,stemp1,aggrx,0)
								aggrx_remove(pos1+l-1)
							loop while pos1>0
						case else
							'cases for special setting modifications
							stemp1 = mid(s,5,len(s)-6)
							result = setting_sg(cmd.record,0,stemp1,EN_STG_SET)
							if result <> EN_STG_STATUS_OK then
								if result = EN_STG_STATUS_FAILURE then stemp1 = "Unable to save the variable"+"("+cmd.record+")"
								if result = EN_STG_STATUS_INVALID then stemp1 = "Setting Value is invalid"+"("+cmd.record+")"
								s = chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"E"+chr(COMMAND_PARAMETERS_SEPARATOR)+stemp1+chr(COMMAND_END)
								aggregate_send(s)
								agg_proc = AGG_IDLE_PHASE
								exit sub
							else
								device_setting_saved(cmd.record,0,stemp1)
								device_modtime_sg("",cmd.record,DEVICE_SET)
							end if
						end select
					else
						if len(s) >254 then goto rx_read
						agg_proc = AGG_IDLE_PHASE
						exit sub
					end if
					s = chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(COMMAND_END)
					aggregate_send(s)
					agg_proc = AGG_IDLE_PHASE
					exit sub						
			case "C":	
				pos1 = 1
				stemp1 = chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)
				
				s = agg_element_extract(pos1,l,stemp1,aggrx,0)
				s = CallFunction(cmd.record,cmd.context_name,s,err)
				if err = NO then
					s = chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"A"+chr(COMMAND_PARAMETERS_SEPARATOR)+s+chr(COMMAND_END)
				else
					s = chr(COMMAND_START)+"R"+chr(COMMAND_PARAMETERS_SEPARATOR)+cmd.id+chr(COMMAND_PARAMETERS_SEPARATOR)+"E"+chr(COMMAND_PARAMETERS_SEPARATOR)+s+chr(COMMAND_END)
				end if

				aggregate_send(s)
				select case cmd.record
					case "init":
						while sock.txlen > 0 
						wend
						sock.close
						device_operation("I")
						device_operation("E")
					case "reboot":
						while sock.txlen > 0 
						wend
						sock.close
						device_operation("E")
				end select
				aggrx_getdata(chr(COMMAND_END))
				agg_proc = AGG_IDLE_PHASE
				exit sub
			end select
		end select
	wend
end sub

#if STORED_EVENT = YES
'=============================================================
public sub ProcessEvents
'Descr: Process Events, and send them to AggreGate server.
	dim s as string 
	dim stemp1 as string(64)	
	dim i, j as byte
	dim rec_num as word
	
	if agg_connected = NO or event_in_proc = YES or event_found = false then exit sub
	rec_num = 1
	device_sys_busy(yes)
	for i = 0 to EVENT_TYPE_NUM-1
		if tbl_select(age(i).event_name) = EN_TBL_STATUS_OK and tbl_record_find(no,"","",1,EN_TBL_SEARCH_DOWN,PL_FD_FIND_EQUAL) = EN_TBL_STATUS_OK then
			s = chr(COMMAND_START)+"M//E/"+age(i).context_name+"/"+age(i).event_name+"/"+age(i).event_level+"///"+chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)
			if agg_set_data_source(age(i).event_name,rec_num) <> OK or rec_num = 0 then 
				device_sys_busy(no)
				exit sub
			end if
			for j = 0 to EVENT_FIELD_NUM-1
				if age(i).event_fields(j) = "" then exit for
				if device_get_field_val(age(i).context_name, age(i).event_fields(j), stemp1) <> OK then 
					device_sys_busy(no)
					exit sub
				end if
				s = s + chr(ELEMENT_START)+stemp1+chr(ELEMENT_END)
			next j
			device_replace_chr(s,"/",chr(COMMAND_PARAMETERS_SEPARATOR))
			s = s+chr(ELEMENT_END)+chr(COMMAND_END)
			aggregate_send(s)
			agg_rec_num = rec_num
			sock.notifysent(0) 
			event_in_proc = yes
			device_sys_busy(no)
			exit sub
		end if		
	next i
	event_found = false
	device_sys_busy(no)
end sub
#endif
'=============================================================
public sub ProcessCurEvents(event_name as string)
	dim s as string 
	dim stemp1 as string(64)	
	dim i, j as byte
	dim rec_num as word
	
	if agg_connected = NO then exit sub
	rec_num = 1
	for i = 0 to EVENT_TYPE_NUM-1
		if event_name = age(i).event_name then exit for
	next i
	if age(i).disk_event = true and event_in_proc = YES then exit sub
	
	if i > EVENT_TYPE_NUM-1 then exit sub
	device_sys_busy(yes)
	s = chr(COMMAND_START)+"M//E/"+age(i).context_name+"/"+age(i).event_name+"/"+age(i).event_level+"///"+chr(ELEMENT_START)+"R"+chr(ELEMENT_NAME_VALUE_SEPARATOR)

	if age(i).disk_event = true then
#if STORED_EVENT= YES	
		if agg_set_data_source(age(i).event_name,rec_num) <> OK or rec_num = 0 then 
			device_sys_busy(no)
			exit sub
		end if
		for j = 0 to EVENT_FIELD_NUM-1
			if age(i).event_fields(j) = "" then exit for
			if device_get_field_val(age(i).context_name, age(i).event_fields(j), stemp1) <> OK then 
				device_sys_busy(no)
				exit sub
			end if
			s = s + chr(ELEMENT_START)+stemp1+chr(ELEMENT_END)
		next j
		cur_event_tbl = event_name
		agg_rec_num = rec_num
#endif
	else
#if INSTANT_EVENT = YES
		s = s+agg_event_buff
#endif
	end if
	device_replace_chr(s,"/",chr(COMMAND_PARAMETERS_SEPARATOR))
	s = s+chr(ELEMENT_END)+chr(COMMAND_END)
	aggregate_send(s)		
	sock.notifysent(0)
	event_in_proc = yes
	device_sys_busy(no)
end sub
'=============================================================
public sub AggreGateConnected
'Descr: Prepaer for AggreGate operations.
	event_in_proc = NO
	agg_login_rpl_timer = AGG_RPL_WAIT_TIME
	agg_proc = AGG_IDLE_PHASE
	aggrx = ""
end sub

'=============================================================
public sub AggreGateDisconnect
'Descr: Close Aggregate connection
	sock.num = SOCK_LS
	sock.discard
end sub

'=============================================================
public sub AggreGateProcessTimer
'Descr: Timer events for the aggregate 
	dim pw as string
	dim comp_result as login_comparison_codes
	dim b as byte
	if setting_get("AR",0) = "0" then exit sub
	sock.num = SOCK_LS
	select case sock.statesimple
	case PL_SSTS_CLOSED:
		if login_mode = CMD_MODE_AGGREGATE then 
			logout
			agg_connected = NO
		else
			pw = setting_get("PW",0)
			comp_result = compare_logins (CMD_MODE_AGGREGATE,pw,SOCK_LS)
			if comp_result = LC_WILL_ACCEPT or comp_result = LC_WILL_ACCEPT_REPEATED_LOGIN or comp_result = LC_WILL_ACCEPT_LOWER_IN_PROGRESS then
				if agg_reconn_timer = 0 then
					sock.connect
					b = asc(random(1))
					agg_reconn_timer = b/AGG_RECONN_TIME
				else
					agg_reconn_timer = agg_reconn_timer - 1
				end if
			end if
		end if
	case PL_SSTS_EST:
		comp_result = compare_logins (CMD_MODE_AGGREGATE,pw,SOCK_LS)
		if comp_result = LC_WILL_REJECT_HIGHER_IN_PROGRESS then
			sock.close
		end if 
		if agg_login_rpl_timer > 0 then 
			if agg_connected = NO then 
				agg_login_rpl_timer = agg_login_rpl_timer-1
				if agg_login_rpl_timer = 0 then sock.close
			else
				agg_login_rpl_timer = 0
			end if
		end if
	end select
end sub

'=============================================================
public sub agg_adjust_record_file(tbl_name as string, proc_rec_num as word)
	tbl_select(tbl_name)
	tbl_record_ptr_sg(proc_rec_num,EN_TBL_SET)
	tbl_record_delete()
	device_modtime_sg("",tbl_name,DEVICE_SET)
	tbl_adjust_size()
	if event_found = false and tbl_select(tbl_name) = EN_TBL_STATUS_OK and tbl_record_find(no,"","",1,EN_TBL_SEARCH_DOWN,PL_FD_FIND_EQUAL) = EN_TBL_STATUS_OK then event_found = true
end sub